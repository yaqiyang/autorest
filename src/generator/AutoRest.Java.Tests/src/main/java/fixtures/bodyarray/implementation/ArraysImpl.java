/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.bodyarray.implementation;

import retrofit2.Retrofit;
import fixtures.bodyarray.Arrays;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.Base64Url;
import com.microsoft.rest.DateTimeRfc1123;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseBuilder;
import com.microsoft.rest.ServiceResponseCallback;
import com.microsoft.rest.Validator;
import fixtures.bodyarray.models.ErrorException;
import fixtures.bodyarray.models.Product;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import okhttp3.ResponseBody;
import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import org.joda.time.Period;
import retrofit2.Call;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.PUT;
import retrofit2.Response;

/**
 * An instance of this class provides access to all the operations defined
 * in Arrays.
 */
public final class ArraysImpl implements Arrays {
    /** The Retrofit service to perform REST calls. */
    private ArraysService service;
    /** The service client containing this operation class. */
    private AutoRestSwaggerBATArrayServiceImpl client;

    /**
     * Initializes an instance of Arrays.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public ArraysImpl(Retrofit retrofit, AutoRestSwaggerBATArrayServiceImpl client) {
        this.service = retrofit.create(ArraysService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Arrays to be
     * used by Retrofit to perform actually REST calls.
     */
    interface ArraysService {
        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/null")
        Call<ResponseBody> getNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/invalid")
        Call<ResponseBody> getInvalid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/empty")
        Call<ResponseBody> getEmpty();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/empty")
        Call<ResponseBody> putEmpty(@Body List<String> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/boolean/tfft")
        Call<ResponseBody> getBooleanTfft();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/prim/boolean/tfft")
        Call<ResponseBody> putBooleanTfft(@Body List<Boolean> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/boolean/true.null.false")
        Call<ResponseBody> getBooleanInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/boolean/true.boolean.false")
        Call<ResponseBody> getBooleanInvalidString();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/integer/1.-1.3.300")
        Call<ResponseBody> getIntegerValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/prim/integer/1.-1.3.300")
        Call<ResponseBody> putIntegerValid(@Body List<Integer> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/integer/1.null.zero")
        Call<ResponseBody> getIntInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/integer/1.integer.0")
        Call<ResponseBody> getIntInvalidString();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/long/1.-1.3.300")
        Call<ResponseBody> getLongValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/prim/long/1.-1.3.300")
        Call<ResponseBody> putLongValid(@Body List<Long> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/long/1.null.zero")
        Call<ResponseBody> getLongInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/long/1.integer.0")
        Call<ResponseBody> getLongInvalidString();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/float/0--0.01-1.2e20")
        Call<ResponseBody> getFloatValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/prim/float/0--0.01-1.2e20")
        Call<ResponseBody> putFloatValid(@Body List<Double> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/float/0.0-null-1.2e20")
        Call<ResponseBody> getFloatInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/float/1.number.0")
        Call<ResponseBody> getFloatInvalidString();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/double/0--0.01-1.2e20")
        Call<ResponseBody> getDoubleValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/prim/double/0--0.01-1.2e20")
        Call<ResponseBody> putDoubleValid(@Body List<Double> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/double/0.0-null-1.2e20")
        Call<ResponseBody> getDoubleInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/double/1.number.0")
        Call<ResponseBody> getDoubleInvalidString();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/string/foo1.foo2.foo3")
        Call<ResponseBody> getStringValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/prim/string/foo1.foo2.foo3")
        Call<ResponseBody> putStringValid(@Body List<String> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/string/foo.null.foo2")
        Call<ResponseBody> getStringWithNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/string/foo.123.foo2")
        Call<ResponseBody> getStringWithInvalid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/uuid/valid")
        Call<ResponseBody> getUuidValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/prim/uuid/valid")
        Call<ResponseBody> putUuidValid(@Body List<UUID> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/uuid/invalidchars")
        Call<ResponseBody> getUuidInvalidChars();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/date/valid")
        Call<ResponseBody> getDateValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/prim/date/valid")
        Call<ResponseBody> putDateValid(@Body List<LocalDate> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/date/invalidnull")
        Call<ResponseBody> getDateInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/date/invalidchars")
        Call<ResponseBody> getDateInvalidChars();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/date-time/valid")
        Call<ResponseBody> getDateTimeValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/prim/date-time/valid")
        Call<ResponseBody> putDateTimeValid(@Body List<DateTime> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/date-time/invalidnull")
        Call<ResponseBody> getDateTimeInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/date-time/invalidchars")
        Call<ResponseBody> getDateTimeInvalidChars();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/date-time-rfc1123/valid")
        Call<ResponseBody> getDateTimeRfc1123Valid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/prim/date-time-rfc1123/valid")
        Call<ResponseBody> putDateTimeRfc1123Valid(@Body List<DateTimeRfc1123> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/duration/valid")
        Call<ResponseBody> getDurationValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/prim/duration/valid")
        Call<ResponseBody> putDurationValid(@Body List<Period> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/byte/valid")
        Call<ResponseBody> getByteValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/prim/byte/valid")
        Call<ResponseBody> putByteValid(@Body List<byte[]> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/byte/invalidnull")
        Call<ResponseBody> getByteInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/prim/base64url/valid")
        Call<ResponseBody> getBase64Url();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/complex/null")
        Call<ResponseBody> getComplexNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/complex/empty")
        Call<ResponseBody> getComplexEmpty();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/complex/itemnull")
        Call<ResponseBody> getComplexItemNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/complex/itemempty")
        Call<ResponseBody> getComplexItemEmpty();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/complex/valid")
        Call<ResponseBody> getComplexValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/complex/valid")
        Call<ResponseBody> putComplexValid(@Body List<Product> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/array/null")
        Call<ResponseBody> getArrayNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/array/empty")
        Call<ResponseBody> getArrayEmpty();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/array/itemnull")
        Call<ResponseBody> getArrayItemNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/array/itemempty")
        Call<ResponseBody> getArrayItemEmpty();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/array/valid")
        Call<ResponseBody> getArrayValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/array/valid")
        Call<ResponseBody> putArrayValid(@Body List<List<String>> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/dictionary/null")
        Call<ResponseBody> getDictionaryNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/dictionary/empty")
        Call<ResponseBody> getDictionaryEmpty();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/dictionary/itemnull")
        Call<ResponseBody> getDictionaryItemNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/dictionary/itemempty")
        Call<ResponseBody> getDictionaryItemEmpty();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("array/dictionary/valid")
        Call<ResponseBody> getDictionaryValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("array/dictionary/valid")
        Call<ResponseBody> putDictionaryValid(@Body List<Map<String, String>> arrayBody);

    }

    /**
     * Get null array value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Integer&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Integer>> getNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getNull();
        return getNullDelegate(call.execute());
    }

    /**
     * Get null array value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Integer>> getNullAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        Call<ResponseBody> call = service.getNull();
        final ServiceCall<List<Integer>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Integer>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Integer>> clientResponse = getNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Integer>> getNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Integer>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get invalid array [1, 2, 3.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Integer&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Integer>> getInvalid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getInvalid();
        return getInvalidDelegate(call.execute());
    }

    /**
     * Get invalid array [1, 2, 3.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Integer>> getInvalidAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        Call<ResponseBody> call = service.getInvalid();
        final ServiceCall<List<Integer>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Integer>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Integer>> clientResponse = getInvalidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Integer>> getInvalidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Integer>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get empty array value [].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Integer&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Integer>> getEmpty() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getEmpty();
        return getEmptyDelegate(call.execute());
    }

    /**
     * Get empty array value [].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Integer>> getEmptyAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        Call<ResponseBody> call = service.getEmpty();
        final ServiceCall<List<Integer>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Integer>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Integer>> clientResponse = getEmptyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Integer>> getEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Integer>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value empty [].
     *
     * @param arrayBody the List&lt;String&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putEmpty(List<String> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putEmpty(arrayBody);
        return putEmptyDelegate(call.execute());
    }

    /**
     * Set array value empty [].
     *
     * @param arrayBody the List&lt;String&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putEmptyAsync(List<String> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putEmpty(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putEmptyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean array value [true, false, false, true].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Boolean&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Boolean>> getBooleanTfft() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getBooleanTfft();
        return getBooleanTfftDelegate(call.execute());
    }

    /**
     * Get boolean array value [true, false, false, true].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Boolean>> getBooleanTfftAsync(final ServiceCallback<List<Boolean>> serviceCallback) {
        Call<ResponseBody> call = service.getBooleanTfft();
        final ServiceCall<List<Boolean>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Boolean>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Boolean>> clientResponse = getBooleanTfftDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Boolean>> getBooleanTfftDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Boolean>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Boolean>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value empty [true, false, false, true].
     *
     * @param arrayBody the List&lt;Boolean&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putBooleanTfft(List<Boolean> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putBooleanTfft(arrayBody);
        return putBooleanTfftDelegate(call.execute());
    }

    /**
     * Set array value empty [true, false, false, true].
     *
     * @param arrayBody the List&lt;Boolean&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putBooleanTfftAsync(List<Boolean> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putBooleanTfft(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putBooleanTfftDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putBooleanTfftDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean array value [true, null, false].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Boolean&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Boolean>> getBooleanInvalidNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getBooleanInvalidNull();
        return getBooleanInvalidNullDelegate(call.execute());
    }

    /**
     * Get boolean array value [true, null, false].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Boolean>> getBooleanInvalidNullAsync(final ServiceCallback<List<Boolean>> serviceCallback) {
        Call<ResponseBody> call = service.getBooleanInvalidNull();
        final ServiceCall<List<Boolean>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Boolean>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Boolean>> clientResponse = getBooleanInvalidNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Boolean>> getBooleanInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Boolean>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Boolean>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean array value [true, 'boolean', false].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Boolean&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Boolean>> getBooleanInvalidString() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getBooleanInvalidString();
        return getBooleanInvalidStringDelegate(call.execute());
    }

    /**
     * Get boolean array value [true, 'boolean', false].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Boolean>> getBooleanInvalidStringAsync(final ServiceCallback<List<Boolean>> serviceCallback) {
        Call<ResponseBody> call = service.getBooleanInvalidString();
        final ServiceCall<List<Boolean>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Boolean>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Boolean>> clientResponse = getBooleanInvalidStringDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Boolean>> getBooleanInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Boolean>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Boolean>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Integer&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Integer>> getIntegerValid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getIntegerValid();
        return getIntegerValidDelegate(call.execute());
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Integer>> getIntegerValidAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        Call<ResponseBody> call = service.getIntegerValid();
        final ServiceCall<List<Integer>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Integer>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Integer>> clientResponse = getIntegerValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Integer>> getIntegerValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Integer>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Integer&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putIntegerValid(List<Integer> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putIntegerValid(arrayBody);
        return putIntegerValidDelegate(call.execute());
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Integer&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putIntegerValidAsync(List<Integer> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putIntegerValid(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putIntegerValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putIntegerValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer array value [1, null, 0].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Integer&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Integer>> getIntInvalidNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getIntInvalidNull();
        return getIntInvalidNullDelegate(call.execute());
    }

    /**
     * Get integer array value [1, null, 0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Integer>> getIntInvalidNullAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        Call<ResponseBody> call = service.getIntInvalidNull();
        final ServiceCall<List<Integer>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Integer>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Integer>> clientResponse = getIntInvalidNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Integer>> getIntInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Integer>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer array value [1, 'integer', 0].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Integer&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Integer>> getIntInvalidString() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getIntInvalidString();
        return getIntInvalidStringDelegate(call.execute());
    }

    /**
     * Get integer array value [1, 'integer', 0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Integer>> getIntInvalidStringAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        Call<ResponseBody> call = service.getIntInvalidString();
        final ServiceCall<List<Integer>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Integer>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Integer>> clientResponse = getIntInvalidStringDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Integer>> getIntInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Integer>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Long&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Long>> getLongValid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getLongValid();
        return getLongValidDelegate(call.execute());
    }

    /**
     * Get integer array value [1, -1, 3, 300].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Long>> getLongValidAsync(final ServiceCallback<List<Long>> serviceCallback) {
        Call<ResponseBody> call = service.getLongValid();
        final ServiceCall<List<Long>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Long>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Long>> clientResponse = getLongValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Long>> getLongValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Long>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Long>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Long&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putLongValid(List<Long> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putLongValid(arrayBody);
        return putLongValidDelegate(call.execute());
    }

    /**
     * Set array value empty [1, -1, 3, 300].
     *
     * @param arrayBody the List&lt;Long&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putLongValidAsync(List<Long> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putLongValid(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putLongValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putLongValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get long array value [1, null, 0].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Long&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Long>> getLongInvalidNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getLongInvalidNull();
        return getLongInvalidNullDelegate(call.execute());
    }

    /**
     * Get long array value [1, null, 0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Long>> getLongInvalidNullAsync(final ServiceCallback<List<Long>> serviceCallback) {
        Call<ResponseBody> call = service.getLongInvalidNull();
        final ServiceCall<List<Long>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Long>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Long>> clientResponse = getLongInvalidNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Long>> getLongInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Long>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Long>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get long array value [1, 'integer', 0].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Long&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Long>> getLongInvalidString() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getLongInvalidString();
        return getLongInvalidStringDelegate(call.execute());
    }

    /**
     * Get long array value [1, 'integer', 0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Long>> getLongInvalidStringAsync(final ServiceCallback<List<Long>> serviceCallback) {
        Call<ResponseBody> call = service.getLongInvalidString();
        final ServiceCall<List<Long>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Long>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Long>> clientResponse = getLongInvalidStringDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Long>> getLongInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Long>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Long>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Double&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Double>> getFloatValid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getFloatValid();
        return getFloatValidDelegate(call.execute());
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Double>> getFloatValidAsync(final ServiceCallback<List<Double>> serviceCallback) {
        Call<ResponseBody> call = service.getFloatValid();
        final ServiceCall<List<Double>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Double>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Double>> clientResponse = getFloatValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Double>> getFloatValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Double>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putFloatValid(List<Double> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putFloatValid(arrayBody);
        return putFloatValidDelegate(call.execute());
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putFloatValidAsync(List<Double> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putFloatValid(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putFloatValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putFloatValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Double&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Double>> getFloatInvalidNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getFloatInvalidNull();
        return getFloatInvalidNullDelegate(call.execute());
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Double>> getFloatInvalidNullAsync(final ServiceCallback<List<Double>> serviceCallback) {
        Call<ResponseBody> call = service.getFloatInvalidNull();
        final ServiceCall<List<Double>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Double>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Double>> clientResponse = getFloatInvalidNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Double>> getFloatInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Double>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Double&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Double>> getFloatInvalidString() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getFloatInvalidString();
        return getFloatInvalidStringDelegate(call.execute());
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Double>> getFloatInvalidStringAsync(final ServiceCallback<List<Double>> serviceCallback) {
        Call<ResponseBody> call = service.getFloatInvalidString();
        final ServiceCall<List<Double>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Double>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Double>> clientResponse = getFloatInvalidStringDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Double>> getFloatInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Double>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Double&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Double>> getDoubleValid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDoubleValid();
        return getDoubleValidDelegate(call.execute());
    }

    /**
     * Get float array value [0, -0.01, 1.2e20].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Double>> getDoubleValidAsync(final ServiceCallback<List<Double>> serviceCallback) {
        Call<ResponseBody> call = service.getDoubleValid();
        final ServiceCall<List<Double>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Double>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Double>> clientResponse = getDoubleValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Double>> getDoubleValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Double>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putDoubleValid(List<Double> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putDoubleValid(arrayBody);
        return putDoubleValidDelegate(call.execute());
    }

    /**
     * Set array value [0, -0.01, 1.2e20].
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putDoubleValidAsync(List<Double> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putDoubleValid(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putDoubleValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putDoubleValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Double&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Double>> getDoubleInvalidNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDoubleInvalidNull();
        return getDoubleInvalidNullDelegate(call.execute());
    }

    /**
     * Get float array value [0.0, null, -1.2e20].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Double>> getDoubleInvalidNullAsync(final ServiceCallback<List<Double>> serviceCallback) {
        Call<ResponseBody> call = service.getDoubleInvalidNull();
        final ServiceCall<List<Double>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Double>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Double>> clientResponse = getDoubleInvalidNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Double>> getDoubleInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Double>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Double&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Double>> getDoubleInvalidString() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDoubleInvalidString();
        return getDoubleInvalidStringDelegate(call.execute());
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Double>> getDoubleInvalidStringAsync(final ServiceCallback<List<Double>> serviceCallback) {
        Call<ResponseBody> call = service.getDoubleInvalidString();
        final ServiceCall<List<Double>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Double>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Double>> clientResponse = getDoubleInvalidStringDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Double>> getDoubleInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Double>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get string array value ['foo1', 'foo2', 'foo3'].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;String&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<String>> getStringValid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getStringValid();
        return getStringValidDelegate(call.execute());
    }

    /**
     * Get string array value ['foo1', 'foo2', 'foo3'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<String>> getStringValidAsync(final ServiceCallback<List<String>> serviceCallback) {
        Call<ResponseBody> call = service.getStringValid();
        final ServiceCall<List<String>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<String>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<String>> clientResponse = getStringValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<String>> getStringValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<String>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value ['foo1', 'foo2', 'foo3'].
     *
     * @param arrayBody the List&lt;String&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putStringValid(List<String> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putStringValid(arrayBody);
        return putStringValidDelegate(call.execute());
    }

    /**
     * Set array value ['foo1', 'foo2', 'foo3'].
     *
     * @param arrayBody the List&lt;String&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putStringValidAsync(List<String> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putStringValid(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putStringValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putStringValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get string array value ['foo', null, 'foo2'].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;String&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<String>> getStringWithNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getStringWithNull();
        return getStringWithNullDelegate(call.execute());
    }

    /**
     * Get string array value ['foo', null, 'foo2'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<String>> getStringWithNullAsync(final ServiceCallback<List<String>> serviceCallback) {
        Call<ResponseBody> call = service.getStringWithNull();
        final ServiceCall<List<String>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<String>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<String>> clientResponse = getStringWithNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<String>> getStringWithNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<String>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get string array value ['foo', 123, 'foo2'].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;String&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<String>> getStringWithInvalid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getStringWithInvalid();
        return getStringWithInvalidDelegate(call.execute());
    }

    /**
     * Get string array value ['foo', 123, 'foo2'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<String>> getStringWithInvalidAsync(final ServiceCallback<List<String>> serviceCallback) {
        Call<ResponseBody> call = service.getStringWithInvalid();
        final ServiceCall<List<String>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<String>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<String>> clientResponse = getStringWithInvalidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<String>> getStringWithInvalidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<String>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<String>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;UUID&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<UUID>> getUuidValid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getUuidValid();
        return getUuidValidDelegate(call.execute());
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<UUID>> getUuidValidAsync(final ServiceCallback<List<UUID>> serviceCallback) {
        Call<ResponseBody> call = service.getUuidValid();
        final ServiceCall<List<UUID>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<UUID>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<UUID>> clientResponse = getUuidValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<UUID>> getUuidValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<UUID>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<UUID>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @param arrayBody the List&lt;UUID&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putUuidValid(List<UUID> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putUuidValid(arrayBody);
        return putUuidValidDelegate(call.execute());
    }

    /**
     * Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].
     *
     * @param arrayBody the List&lt;UUID&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putUuidValidAsync(List<UUID> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putUuidValid(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putUuidValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putUuidValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo'].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;UUID&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<UUID>> getUuidInvalidChars() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getUuidInvalidChars();
        return getUuidInvalidCharsDelegate(call.execute());
    }

    /**
     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<UUID>> getUuidInvalidCharsAsync(final ServiceCallback<List<UUID>> serviceCallback) {
        Call<ResponseBody> call = service.getUuidInvalidChars();
        final ServiceCall<List<UUID>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<UUID>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<UUID>> clientResponse = getUuidInvalidCharsDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<UUID>> getUuidInvalidCharsDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<UUID>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<UUID>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;LocalDate&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<LocalDate>> getDateValid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDateValid();
        return getDateValidDelegate(call.execute());
    }

    /**
     * Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<LocalDate>> getDateValidAsync(final ServiceCallback<List<LocalDate>> serviceCallback) {
        Call<ResponseBody> call = service.getDateValid();
        final ServiceCall<List<LocalDate>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<LocalDate>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<LocalDate>> clientResponse = getDateValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<LocalDate>> getDateValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<LocalDate>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<LocalDate>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value  ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @param arrayBody the List&lt;LocalDate&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putDateValid(List<LocalDate> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putDateValid(arrayBody);
        return putDateValidDelegate(call.execute());
    }

    /**
     * Set array value  ['2000-12-01', '1980-01-02', '1492-10-12'].
     *
     * @param arrayBody the List&lt;LocalDate&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putDateValidAsync(List<LocalDate> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putDateValid(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putDateValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putDateValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date array value ['2012-01-01', null, '1776-07-04'].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;LocalDate&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<LocalDate>> getDateInvalidNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDateInvalidNull();
        return getDateInvalidNullDelegate(call.execute());
    }

    /**
     * Get date array value ['2012-01-01', null, '1776-07-04'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<LocalDate>> getDateInvalidNullAsync(final ServiceCallback<List<LocalDate>> serviceCallback) {
        Call<ResponseBody> call = service.getDateInvalidNull();
        final ServiceCall<List<LocalDate>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<LocalDate>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<LocalDate>> clientResponse = getDateInvalidNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<LocalDate>> getDateInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<LocalDate>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<LocalDate>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date array value ['2011-03-22', 'date'].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;LocalDate&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<LocalDate>> getDateInvalidChars() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDateInvalidChars();
        return getDateInvalidCharsDelegate(call.execute());
    }

    /**
     * Get date array value ['2011-03-22', 'date'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<LocalDate>> getDateInvalidCharsAsync(final ServiceCallback<List<LocalDate>> serviceCallback) {
        Call<ResponseBody> call = service.getDateInvalidChars();
        final ServiceCall<List<LocalDate>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<LocalDate>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<LocalDate>> clientResponse = getDateInvalidCharsDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<LocalDate>> getDateInvalidCharsDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<LocalDate>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<LocalDate>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;DateTime&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<DateTime>> getDateTimeValid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDateTimeValid();
        return getDateTimeValidDelegate(call.execute());
    }

    /**
     * Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<DateTime>> getDateTimeValidAsync(final ServiceCallback<List<DateTime>> serviceCallback) {
        Call<ResponseBody> call = service.getDateTimeValid();
        final ServiceCall<List<DateTime>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<DateTime>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<DateTime>> clientResponse = getDateTimeValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<DateTime>> getDateTimeValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<DateTime>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<DateTime>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @param arrayBody the List&lt;DateTime&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putDateTimeValid(List<DateTime> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putDateTimeValid(arrayBody);
        return putDateTimeValidDelegate(call.execute());
    }

    /**
     * Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].
     *
     * @param arrayBody the List&lt;DateTime&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putDateTimeValidAsync(List<DateTime> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putDateTimeValid(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putDateTimeValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putDateTimeValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', null].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;DateTime&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<DateTime>> getDateTimeInvalidNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDateTimeInvalidNull();
        return getDateTimeInvalidNullDelegate(call.execute());
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', null].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<DateTime>> getDateTimeInvalidNullAsync(final ServiceCallback<List<DateTime>> serviceCallback) {
        Call<ResponseBody> call = service.getDateTimeInvalidNull();
        final ServiceCall<List<DateTime>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<DateTime>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<DateTime>> clientResponse = getDateTimeInvalidNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<DateTime>> getDateTimeInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<DateTime>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<DateTime>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', 'date-time'].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;DateTime&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<DateTime>> getDateTimeInvalidChars() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDateTimeInvalidChars();
        return getDateTimeInvalidCharsDelegate(call.execute());
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', 'date-time'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<DateTime>> getDateTimeInvalidCharsAsync(final ServiceCallback<List<DateTime>> serviceCallback) {
        Call<ResponseBody> call = service.getDateTimeInvalidChars();
        final ServiceCall<List<DateTime>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<DateTime>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<DateTime>> clientResponse = getDateTimeInvalidCharsDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<DateTime>> getDateTimeInvalidCharsDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<DateTime>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<DateTime>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;DateTime&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<DateTime>> getDateTimeRfc1123Valid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDateTimeRfc1123Valid();
        ServiceResponse<List<DateTimeRfc1123>> response = getDateTimeRfc1123ValidDelegate(call.execute());
        List<DateTime> body = null;
        if (response.getBody() != null) {
            body = new ArrayList<DateTime>();
            for (DateTimeRfc1123 item : response.getBody()) {
                DateTime value;
                value = item.getDateTime();
                body.add(value);
            }
        }
        return new ServiceResponse<List<DateTime>>(body, response.getResponse());
    }

    /**
     * Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<DateTime>> getDateTimeRfc1123ValidAsync(final ServiceCallback<List<DateTime>> serviceCallback) {
        Call<ResponseBody> call = service.getDateTimeRfc1123Valid();
        final ServiceCall<List<DateTime>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<DateTime>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<DateTimeRfc1123>> result = getDateTimeRfc1123ValidDelegate(response);
                    List<DateTime> body = null;
                    if (result.getBody() != null) {
                        body = new ArrayList<DateTime>();
                        for (DateTimeRfc1123 item : result.getBody()) {
                            DateTime value;
                            value = item.getDateTime();
                            body.add(value);
                        }
                    }
                    ServiceResponse<List<DateTime>> clientResponse = new ServiceResponse<List<DateTime>>(body, result.getResponse());
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<DateTimeRfc1123>> getDateTimeRfc1123ValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<DateTimeRfc1123>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<DateTimeRfc1123>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @param arrayBody the List&lt;DateTimeRfc1123&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putDateTimeRfc1123Valid(List<DateTime> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        List<DateTimeRfc1123> arrayBodyConverted = new ArrayList<DateTimeRfc1123>();
        for (DateTime item : arrayBody) {
            DateTimeRfc1123 value = new DateTimeRfc1123(item);
            arrayBodyConverted.add(value);
        }
        Call<ResponseBody> call = service.putDateTimeRfc1123Valid(arrayBodyConverted);
        return putDateTimeRfc1123ValidDelegate(call.execute());
    }

    /**
     * Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].
     *
     * @param arrayBody the List&lt;DateTimeRfc1123&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putDateTimeRfc1123ValidAsync(List<DateTime> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        List<DateTimeRfc1123> arrayBodyConverted = new ArrayList<DateTimeRfc1123>();
        for (DateTime item : arrayBody) {
            DateTimeRfc1123 value = new DateTimeRfc1123(item);
            arrayBodyConverted.add(value);
        }
        Call<ResponseBody> call = service.putDateTimeRfc1123Valid(arrayBodyConverted);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putDateTimeRfc1123ValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putDateTimeRfc1123ValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Period&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Period>> getDurationValid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDurationValid();
        return getDurationValidDelegate(call.execute());
    }

    /**
     * Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Period>> getDurationValidAsync(final ServiceCallback<List<Period>> serviceCallback) {
        Call<ResponseBody> call = service.getDurationValid();
        final ServiceCall<List<Period>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Period>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Period>> clientResponse = getDurationValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Period>> getDurationValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Period>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Period>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @param arrayBody the List&lt;Period&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putDurationValid(List<Period> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putDurationValid(arrayBody);
        return putDurationValidDelegate(call.execute());
    }

    /**
     * Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S'].
     *
     * @param arrayBody the List&lt;Period&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putDurationValidAsync(List<Period> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putDurationValid(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putDurationValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putDurationValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;byte[]&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<byte[]>> getByteValid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getByteValid();
        return getByteValidDelegate(call.execute());
    }

    /**
     * Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<byte[]>> getByteValidAsync(final ServiceCallback<List<byte[]>> serviceCallback) {
        Call<ResponseBody> call = service.getByteValid();
        final ServiceCall<List<byte[]>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<byte[]>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<byte[]>> clientResponse = getByteValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<byte[]>> getByteValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<byte[]>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<byte[]>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base 64.
     *
     * @param arrayBody the List&lt;byte[]&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putByteValid(List<byte[]> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putByteValid(arrayBody);
        return putByteValidDelegate(call.execute());
    }

    /**
     * Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base 64.
     *
     * @param arrayBody the List&lt;byte[]&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putByteValidAsync(List<byte[]> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putByteValid(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putByteValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putByteValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;byte[]&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<byte[]>> getByteInvalidNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getByteInvalidNull();
        return getByteInvalidNullDelegate(call.execute());
    }

    /**
     * Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<byte[]>> getByteInvalidNullAsync(final ServiceCallback<List<byte[]>> serviceCallback) {
        Call<ResponseBody> call = service.getByteInvalidNull();
        final ServiceCall<List<byte[]>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<byte[]>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<byte[]>> clientResponse = getByteInvalidNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<byte[]>> getByteInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<byte[]>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<byte[]>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get array value ['a string that gets encoded with base64url', 'test string' 'Lorem ipsum'] with the items base64url encoded.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;byte[]&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<byte[]>> getBase64Url() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getBase64Url();
        ServiceResponse<List<Base64Url>> response = getBase64UrlDelegate(call.execute());
        List<byte[]> body = null;
        if (response.getBody() != null) {
            body = new ArrayList<byte[]>();
            for (Base64Url item : response.getBody()) {
                byte[] value;
                value = item.getDecodedBytes();
                body.add(value);
            }
        }
        return new ServiceResponse<List<byte[]>>(body, response.getResponse());
    }

    /**
     * Get array value ['a string that gets encoded with base64url', 'test string' 'Lorem ipsum'] with the items base64url encoded.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<byte[]>> getBase64UrlAsync(final ServiceCallback<List<byte[]>> serviceCallback) {
        Call<ResponseBody> call = service.getBase64Url();
        final ServiceCall<List<byte[]>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<byte[]>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Base64Url>> result = getBase64UrlDelegate(response);
                    List<byte[]> body = null;
                    if (result.getBody() != null) {
                        body = new ArrayList<byte[]>();
                        for (Base64Url item : result.getBody()) {
                            byte[] value;
                            value = item.getDecodedBytes();
                            body.add(value);
                        }
                    }
                    ServiceResponse<List<byte[]>> clientResponse = new ServiceResponse<List<byte[]>>(body, result.getResponse());
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Base64Url>> getBase64UrlDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Base64Url>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Base64Url>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get array of complex type null value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Product&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Product>> getComplexNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getComplexNull();
        return getComplexNullDelegate(call.execute());
    }

    /**
     * Get array of complex type null value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Product>> getComplexNullAsync(final ServiceCallback<List<Product>> serviceCallback) {
        Call<ResponseBody> call = service.getComplexNull();
        final ServiceCall<List<Product>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Product>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Product>> clientResponse = getComplexNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Product>> getComplexNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Product>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Product>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get empty array of complex type [].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Product&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Product>> getComplexEmpty() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getComplexEmpty();
        return getComplexEmptyDelegate(call.execute());
    }

    /**
     * Get empty array of complex type [].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Product>> getComplexEmptyAsync(final ServiceCallback<List<Product>> serviceCallback) {
        Call<ResponseBody> call = service.getComplexEmpty();
        final ServiceCall<List<Product>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Product>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Product>> clientResponse = getComplexEmptyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Product>> getComplexEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Product>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Product>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string': '6'}].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Product&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Product>> getComplexItemNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getComplexItemNull();
        return getComplexItemNullDelegate(call.execute());
    }

    /**
     * Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string': '6'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Product>> getComplexItemNullAsync(final ServiceCallback<List<Product>> serviceCallback) {
        Call<ResponseBody> call = service.getComplexItemNull();
        final ServiceCall<List<Product>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Product>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Product>> clientResponse = getComplexItemNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Product>> getComplexItemNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Product>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Product>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string': '6'}].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Product&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Product>> getComplexItemEmpty() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getComplexItemEmpty();
        return getComplexItemEmptyDelegate(call.execute());
    }

    /**
     * Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string': '6'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Product>> getComplexItemEmptyAsync(final ServiceCallback<List<Product>> serviceCallback) {
        Call<ResponseBody> call = service.getComplexItemEmpty();
        final ServiceCall<List<Product>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Product>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Product>> clientResponse = getComplexItemEmptyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Product>> getComplexItemEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Product>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Product>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Product&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Product>> getComplexValid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getComplexValid();
        return getComplexValidDelegate(call.execute());
    }

    /**
     * Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Product>> getComplexValidAsync(final ServiceCallback<List<Product>> serviceCallback) {
        Call<ResponseBody> call = service.getComplexValid();
        final ServiceCall<List<Product>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Product>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Product>> clientResponse = getComplexValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Product>> getComplexValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Product>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Product>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @param arrayBody the List&lt;Product&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putComplexValid(List<Product> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putComplexValid(arrayBody);
        return putComplexValidDelegate(call.execute());
    }

    /**
     * Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].
     *
     * @param arrayBody the List&lt;Product&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putComplexValidAsync(List<Product> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putComplexValid(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putComplexValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putComplexValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get a null array.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<List<String>>> getArrayNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getArrayNull();
        return getArrayNullDelegate(call.execute());
    }

    /**
     * Get a null array.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<List<String>>> getArrayNullAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        Call<ResponseBody> call = service.getArrayNull();
        final ServiceCall<List<List<String>>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<List<String>>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<List<String>>> clientResponse = getArrayNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<List<String>>> getArrayNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<List<String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an empty array [].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<List<String>>> getArrayEmpty() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getArrayEmpty();
        return getArrayEmptyDelegate(call.execute());
    }

    /**
     * Get an empty array [].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<List<String>>> getArrayEmptyAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        Call<ResponseBody> call = service.getArrayEmpty();
        final ServiceCall<List<List<String>>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<List<String>>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<List<String>>> clientResponse = getArrayEmptyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<List<String>>> getArrayEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<List<String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<List<String>>> getArrayItemNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getArrayItemNull();
        return getArrayItemNullDelegate(call.execute());
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<List<String>>> getArrayItemNullAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        Call<ResponseBody> call = service.getArrayItemNull();
        final ServiceCall<List<List<String>>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<List<String>>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<List<String>>> clientResponse = getArrayItemNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<List<String>>> getArrayItemNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<List<String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<List<String>>> getArrayItemEmpty() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getArrayItemEmpty();
        return getArrayItemEmptyDelegate(call.execute());
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<List<String>>> getArrayItemEmptyAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        Call<ResponseBody> call = service.getArrayItemEmpty();
        final ServiceCall<List<List<String>>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<List<String>>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<List<String>>> clientResponse = getArrayItemEmptyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<List<String>>> getArrayItemEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<List<String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<List<String>>> getArrayValid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getArrayValid();
        return getArrayValidDelegate(call.execute());
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<List<String>>> getArrayValidAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        Call<ResponseBody> call = service.getArrayValid();
        final ServiceCall<List<List<String>>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<List<String>>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<List<String>>> clientResponse = getArrayValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<List<String>>> getArrayValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<List<String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @param arrayBody the List&lt;List&lt;String&gt;&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putArrayValid(List<List<String>> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putArrayValid(arrayBody);
        return putArrayValidDelegate(call.execute());
    }

    /**
     * Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].
     *
     * @param arrayBody the List&lt;List&lt;String&gt;&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putArrayValidAsync(List<List<String>> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putArrayValid(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putArrayValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putArrayValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of Dictionaries with value null.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Map<String, String>>> getDictionaryNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDictionaryNull();
        return getDictionaryNullDelegate(call.execute());
    }

    /**
     * Get an array of Dictionaries with value null.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Map<String, String>>> getDictionaryNullAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        Call<ResponseBody> call = service.getDictionaryNull();
        final ServiceCall<List<Map<String, String>>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Map<String, String>>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Map<String, String>>> clientResponse = getDictionaryNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Map<String, String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Map<String, String>>> getDictionaryEmpty() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDictionaryEmpty();
        return getDictionaryEmptyDelegate(call.execute());
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Map<String, String>>> getDictionaryEmptyAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        Call<ResponseBody> call = service.getDictionaryEmpty();
        final ServiceCall<List<Map<String, String>>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Map<String, String>>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Map<String, String>>> clientResponse = getDictionaryEmptyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Map<String, String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Map<String, String>>> getDictionaryItemNull() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDictionaryItemNull();
        return getDictionaryItemNullDelegate(call.execute());
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Map<String, String>>> getDictionaryItemNullAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        Call<ResponseBody> call = service.getDictionaryItemNull();
        final ServiceCall<List<Map<String, String>>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Map<String, String>>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Map<String, String>>> clientResponse = getDictionaryItemNullDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryItemNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Map<String, String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Map<String, String>>> getDictionaryItemEmpty() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDictionaryItemEmpty();
        return getDictionaryItemEmptyDelegate(call.execute());
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Map<String, String>>> getDictionaryItemEmptyAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        Call<ResponseBody> call = service.getDictionaryItemEmpty();
        final ServiceCall<List<Map<String, String>>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Map<String, String>>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Map<String, String>>> clientResponse = getDictionaryItemEmptyDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryItemEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Map<String, String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the List&lt;Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public ServiceResponse<List<Map<String, String>>> getDictionaryValid() throws ErrorException, IOException {
        Call<ResponseBody> call = service.getDictionaryValid();
        return getDictionaryValidDelegate(call.execute());
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<List<Map<String, String>>> getDictionaryValidAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        Call<ResponseBody> call = service.getDictionaryValid();
        final ServiceCall<List<Map<String, String>>> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<List<Map<String, String>>>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<List<Map<String, String>>> clientResponse = getDictionaryValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<List<Map<String, String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<List<Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param arrayBody the List&lt;Map&lt;String, String&gt;&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public ServiceResponse<Void> putDictionaryValid(List<Map<String, String>> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putDictionaryValid(arrayBody);
        return putDictionaryValidDelegate(call.execute());
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].
     *
     * @param arrayBody the List&lt;Map&lt;String, String&gt;&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link Call} object
     */
    public ServiceCall<Void> putDictionaryValidAsync(List<Map<String, String>> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Call<ResponseBody> call = service.putDictionaryValid(arrayBody);
        final ServiceCall<Void> serviceCall = new ServiceCall<>(call);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCall, serviceCallback) {
            @Override
            public void onResponse(Call<ResponseBody> call, Response<ResponseBody> response) {
                try {
                    ServiceResponse<Void> clientResponse = putDictionaryValidDelegate(response);
                    if (serviceCallback != null) {
                        serviceCallback.success(clientResponse);
                    }
                    serviceCall.success(clientResponse);
                } catch (ErrorException | IOException exception) {
                    if (serviceCallback != null) {
                        serviceCallback.failure(exception);
                    }
                    serviceCall.failure(exception);
                }
            }
        });
        return serviceCall;
    }

    private ServiceResponse<Void> putDictionaryValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

}
